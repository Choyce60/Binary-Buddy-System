Memory (Object)
	-size
	Boolean hasBuddy
	Memory buddy
	Process A

Split()

Merge()

Main
	-LinkedList<Memory>  thingsWeNeed


//Round the input to a power of 2
//example if inputBlock = 7, return will be 8

public int roundSize (int inputBlock)
   {
        int power = 2;        
        while (power < inputBlock) {
                power = power * 2;
        }
	int blockAsPowerTwo = power;
        return blockAsPowerTwo;
   }
   
   
   
public boolean hasBuddy(Integer buddy){
  Node current = node;
  
  //go through every element/block in list checking if input equals any blocks
  //in linked list return true is hasbuddy
  
 public boolean hasBuddy(Node root, Integer buddy){
    Node current = root;
    while(current != null){
       
        if(buddy.equals(current.buddy) && buddy.next(current.buddy).equals(current.buddy) ){
       
        if(current.buddy.equals(buddy)){
      
         return true;
        }
        currentNode = root.next();//update current node
    }
    return false;
}

public int memoryBuddy(Integer buddy){
  Node current = node;
  
  //go through every element/block in list checking if input equals any blocks
  //in linked list
  while (current != null) {
    if (current.buddy.equals(buddy)) {
      return buddy;
    } else {
      current = current.next();
    }
  }
  return null;
}









//What I have so far for basic interface, Also uses a seperate Memory class added below!
import java.util.*;

public class BinaryBuddySystem 
{
	public static int BINARY_MODIFIER = 2;
	public static Scanner scanInt = new Scanner(System.in);
	
	public static void main(String[] args) 
	{
		int inputChoiceNum = 0;///addddd
			boolean proceed = false;///adddd
			while(!proceed)///adddd
			{
				inputChoiceNum = inputChoice();
				if(inputChoiceNum<1 && inputChoiceNum>2)
				{
					System.out.println("Invalid Numeric Input");
				}
				else
				{
					proceed = true;
				}
			}
			
		int memoryBlockSize = setSystemSize();
		System.out.println(memoryBlockSize);
		
		ArrayList<Memory> currentBank = createMemoryBlock(memoryBlockSize);
		System.out.println(currentBank.get(0).getValue());
		
		while(0==0)
		{
			System.out.println("Please indicate a numeric action:"+"\n"+"1: Check System Status" +"\n"+"2: Add A Process"+"\n"+"3: Deactivate A Process"+"\n"+"4: Exit");
			int input = scanInt.nextInt();
			if(!(input>0 && input<5))
			{
				System.out.println("Invalid Numeric Input");
			}
			else
			{
				if(input==1)
				{
					for(int i = 0; i<currentBank.size();i++)
					{
						System.out.println("Location: "+i+"\t"+"Value: "+currentBank.get(i).getValue()+"\t"+"Active Process? "+currentBank.get(i).getActive());
					}
				}
				else if(input==2)
				{
					addProcess(currentBank,createProcess());
				}
				else if(input==3)
				{
					System.out.println("Please input the name of the process to deallocate: ");
					String target = scanInt.next();
					deallocate(currentBank, target);
					System.out.println(currentBank);	
				}
				else if(input==4)
				{
					break;
				}
			}
		}
	}
	
	private static int roundSize (int inputBlock)
	   {
	        int power = 2;        
	        while (power < inputBlock) {
	                power = power * 2;
	        }
		int blockAsPowerTwo = power;
	        return blockAsPowerTwo;
	   }
	   
	   private static void runFileInput() throws IOException
		{
			Reader reader = new FileReader("../binarybuddy/src/BinaryBuddy/MemoryInput");
	        BufferedReader br = new BufferedReader(reader);
	        String line;
	        if((line = br.readLine()) != null)
	        {
	        	int memoryBlockSize = roundSize(Integer.parseInt(line));
	        	ArrayList<Memory> currentBank = createMemoryBlock(memoryBlockSize);
		        while ((line = br.readLine()) != null) 
		        {
		        	int input = Integer.parseInt(line);
				
					if(input==1)
					{
						for(int i = 0; i<currentBank.size();i++)
						{
							System.out.println("Location: "+i+"\t"+"Value: "+currentBank.get(i).getValue()+"\t"+"Active Process? "+currentBank.get(i).getActive());	
						}						
					}
					else if(input==2)
					{
						addProcess(currentBank,createProcess());
					}
					else if(input==3)
					{
						
					}
		        }
	        }
	        else
	        {
	        	System.out.println("File Is Empty Or Not Formatted Correctly.");
	        }
	}
	
	private static int setSystemSize()
	{
		System.out.println("Please input the the size of allocated space for memory storage (rounded to the nearest power of 2 in Mb): ");
		int size = scanInt.nextInt();
		return roundSize(size);
	}
	
	private static ArrayList<Memory> createMemoryBlock(int systemSize)
	{
		Memory x = new Memory(systemSize);
		ArrayList<Memory> memoryBlock = new ArrayList<Memory>();
		memoryBlock.add(x);
		return memoryBlock;
	}
	
	private static Memory createProcess()
	{
		System.out.println("Please input the size of the process (in Mb): ");
		int size = scanInt.nextInt();
		Memory newProcess = new Memory(size);
		System.out.println("Please input a string to identify this process: ");
		String name = scanInt.next();
		newProcess.setID(name);
		return newProcess;
	}
	
	private static ArrayList<Memory> addProcess(ArrayList<Memory> currentState, Memory newProcess)
	{
		for(int i = 0; i<currentState.size(); i++)
		{
			int roundedProcessValue = roundSize(newProcess.getValue());
			if(!currentState.get(i).getActive())
			{
				if(currentState.get(i).getValue()==roundedProcessValue)
				{
					currentState.set(i, newProcess);
					break;
				}
				else if(currentState.get(i).getValue()>roundedProcessValue)
				{
					currentState = split(currentState, i);
					i=-1;
				}
			}
		}
		return currentState;
	}
	
	private static ArrayList<Memory> split(ArrayList<Memory> editableList, int locationOfEdit)
	{
		if(editableList.get(locationOfEdit).getValue()>1)
		{
			int tempNum = editableList.get(locationOfEdit).getValue()/2;
			editableList.get(locationOfEdit).setValue(tempNum);
			Memory splitMem = new Memory(tempNum);
			editableList.add(locationOfEdit, splitMem);
			return editableList;
		}
		return null;
	}
	
	//Method to deallocate memory, uses a Memory object as a parameter
	//sets active to false and attempts to merge
	//returns either the merge is successful or only the deallocated memory will have its active flag changed 
	private static ArrayList<Memory> deallocate(ArrayList<Memory> editableList, String name)
	{
		Memory finishedMem = findProcess(editableList, name);
		finishedMem.setActive(false);
		return merge(editableList,finishedMem);
	}
	
	//Merge method for merging 2 inactive buddies
	//Will be called in deallocate memory method which will pass on a Memory parameter - Craig
	private static ArrayList<Memory> merge(ArrayList<Memory> editableList,Memory emptyMem)
	{
		if(!(emptyMem.getActive())&& (emptyMem.getHasBuddy()))
		{
			if(!(emptyMem.getBuddy().getActive()))
			{
				editableList.remove(emptyMem.getBuddy());
				emptyMem.setValue(emptyMem.getValue()*BINARY_MODIFIER);
				
			}
			
			
		}
		return editableList;
	}
	//Method to find a process by its ID in the memory arraylist
	//precondition: Process is in memory
	private static Memory findProcess(ArrayList<Memory> editableList,String name)
	{
		
			
			for(int i = 0;i<editableList.size()-1;i++)
			{
				if(editableList.get(i).getName().equals(name))
					return editableList.get(i);
			}
			System.out.println("Process was not found in memory!");
			return new Memory(0);
		
}



public class Memory 
{
	private String id;
	private int value;
	private boolean active;
	private boolean hasBuddy;
	private Memory buddy;
	
	public Memory(int value)
	{
		this.value = value;
		this.active = false;
		this.hasBuddy = false;
		buddy = null;
	}

	public int getValue() 
	{
		return value;
	}

	public void setValue(int value) 
	{
		this.value = value;
	}
	
	public boolean getActive()
	{
		return active;
	}
	
	public void setActive(boolean active)
	{
		this.active = active;
	}
	public boolean getHasBuddy()
	{
		return hasBuddy;
	}
	
	public void setHasBuddy(boolean tf)
	{
		hasBuddy = tf;
	}
	public void setBuddy(Memory newFriend)
	{
		buddy = newFriend;
	}
	public Memory getBuddy()
	{
		return buddy;
	}
	public void setID(String name)
	{
		id = name;
	}
	public String getName()
	{
		return id;
	}
}










